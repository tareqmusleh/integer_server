# -*- coding: utf-8 -*-

from django.utils.lru_cache import lru_cache
from itertools import count, groupby
from operator import mul

@lru_cache(maxsize=None)
def fibonacci(n):
  """Return the nth fibonacci term."""

  if n <= 1:
    return n
  else:
    return fibonacci(n-2) + fibonacci(n-1)


def fibonacci_sequence(n):
	""" 
	Generate n terms of the fibonacci sequence. 
	The next number in the sequence is generated by adding the previous two numbers.
	"""

	a, b = 0, 1    
	fibonacci_list = []
	for i in xrange(n):
		fibonacci_list.append(a)
		a, b = b, a+b

	return fibonacci_list

def nth_happy(n):
	"""" Returns the nth happy number. """

	# negative numbers are not supported, return None
	if n < 0:
		return

	sequence = happy_sequence(n+1)
	return sequence[n]

def happy_sequence(n):
	"""
	Generates the first n terms of the happy sequence.
	Because of the way happy numbers are generated, we simply continue iterating 
	until the length of the sequence list is equal to n. 
	"""
	if n < 1: 
		return []
	
	sequence = []
	for i in count(1):
		if is_happy(i):
			sequence.append(i)
		if len(sequence) == n:
			return sequence

def is_happy(number):
	"""
	Determines if a number is a happy number. A happy number is defined by a number
	in which the sum of squares of its digits eventually is 1. An unhappy number loops
	infinitely, eventually generating the same numbers over and over again.

	Happy number example 13:
	1**2 + 3**2 = 10
	1**2 + 0**2 = 1 thus, 13 is a happy number

	Unhappy number example 14:
	1**2 + 4**2 = 17
	1**2 + 7**2 = 50
	5**2 + 0**2 = 25
	2**2 + 5**2 = 29
	2**2 + 9**2 = 85
	... 
	...
	"""

	used = set()
	while number != 1:
		# find the sum of the squares of the digits, then add it to our used set.
		# once a number we repeats itself, we know it can't be a happy number.
		number = sum(int(i)**2 for i in str(number))
		if number in used:
			return False
		used.add(number)

	return True

def abundant_sequence(n):
	"""
	Generates n abundant terms.
	"""

	if n < 1: 
		return []

	sequence = []
	for i in count(1):
		if is_abundant(i):
			sequence.append(i)
		if len(sequence) == n:
			return sequence

def nth_abundant(n):
	"""
	Returns the nth abundant number from the abundant sequence.

	This is 0 based index, so 0 is the first element.
	If n is less than 0, then None is returned.
	"""

	# negative numbers are not supported, return None
	if n < 0:
		return

	sequence = abundant_sequence(n+1)
	return sequence[n]

def is_abundant(number):
	"""
	An abundant number is when the sum of all of its proper divisors.
	Example: 
	12 is abundant because its divisors are : 1, 2, 3, 4 and 6
	The sum of its divisors is 16, which is greater than 12.
	"""
	return sum(__calculate_all_proper_divisors(number)) > number


def baum_sweet_sequence(n):

	""" 
	Generates the baum sweet sequence for n terms. The baum sweet sequence
	is defined by: a(n) = 1 if binary representation of n contains no block of consecutive zeros of odd length; 
	otherwise a(n) = 0.
	"""

	sequence = []
	for i in xrange(n):
		binary = "{0:b}".format(i)
		# this is the one off case where the binary is only 1 digit, as in 0 and 1
		if len(binary) == 1:
			sequence.append(1)
			continue
		# group the binary by consecutive 0s and 1s
		# then check for when the digit is 0, if it's an odd number of 0s
		# then 0 is added to the sequence	
		for digit, digit_count in groupby(binary):
			if digit == '0' and len(list(digit_count)) % 2 != 0:
				sequence.append(0)
				break
		else:
			sequence.append(1)

	return sequence

def nth_baum_sweet(n):
	""" 
	Returns the nth term of the baum sweet sequence. This is 0 based index, so 0 is the first element.
	If n is less than 0, then None is returned.
	"""

	# negative numbers are not supported, return None
	if n < 0:
		return

	sequence = baum_sweet_sequence(n+1)
	return sequence[n]


def is_sphenic(n, used):
	"""
	Determines if n is a sphenic number by checking if it is divisible by 3 disticnt prime numbers
	and the product of those 3 distinct prime numbers is not already used.
	"""

	all_divisors = __calculate_all_proper_divisors_without_1(n)
	distinct_primes = {i for i in all_divisors if __is_prime(i)}
	return len(distinct_primes) == 3 and reduce(mul, distinct_primes) not in used


def sphenic_sequence(n):

	"""
	Generates the sphenic number sequence for n terms.
	"""

	if n < 1: 
		return []

	sequence = []
	used = set()
	for i in count(1):
		if is_sphenic(i, used):
			# if i is sphenic, add it to the sequence, and add it to the used set
			# so that we can't add another number with the same divisible distinct prime product
			sequence.append(i)
			used.add(i)
		if len(sequence) == n:
			return sequence


def nth_sphenic(n):
	""" 
	Returns the nth term of the sphenic number sequence. This is 0 based index, so 0 is the first element.
	If n is less than 0, then None is returned.
	"""

	# negative numbers are not supported, return None
	if n < 0:
		return

	sequence = sphenic_sequence(n+1)
	return sequence[n]

def __calculate_all_proper_divisors(n):
	""" Returns all the proper divisors of n. """
	return [x for x in range(1, (n + 1) / 2 + 1) if n % x == 0 and n != x]

def __calculate_all_proper_divisors_without_1(n):
	""" Returns all the proper divisors of n without 1. """
	return [x for x in range(1, (n + 1) / 2 + 1) if n % x == 0 and n != x and x != 1]

def __is_prime(n):
	""" Determines if n is prime  """
	return all(n % i for i in xrange(2, n))